- # 盛趣游戏前端面试复盘（八股文知识点深度解析）

  ## 面试概览
  - **时长**：45分钟  （30分钟八股）
  - **核心环节**：自我介绍 + 八股文提问（12个重点方向） + 项目亮点 + 反问  

  ---

  ## 八股文知识点详解（表格对比版）

  ### 1. Vue 2 和 Vue 3 的区别
  | **对比维度**        | **Vue 2**                                                    | **Vue 3**                                                    |
  | ------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | **响应式原理**      | 基于 `Object.defineProperty` 劫持对象属性（无法监听新增/删除属性） | 基于 `Proxy` 代理整个对象（支持动态新增/删除属性，性能更优） |
  | **Composition API** | 不支持（依赖 Options API：data/methods/computed 等选项式开发） | 新增 `setup` 函数 + Composition API（逻辑复用更灵活，解决 Options API 拆分问题） |
  | **虚拟DOM优化**     | 全量对比更新                                                 | 静态节点提升（Static Hoisting）、Patch Flag 优化（精准更新动态节点） |
  | **Tree-shaking**    | 所有 API 打包进生产环境（体积大）                            | 按需引入 API（如 `ref`/`reactive`，减少打包体积）            |
  | **其他特性**        | 不支持 Fragment（单根节点）、Teleport（传送门）、Suspense（异步组件） | 支持 Fragment（多根节点）、Teleport（跨 DOM 层级渲染）、Suspense（异步加载优化） |

  ---

  ### 2. TypeScript (TS) 和 JavaScript (JS) 的区别
  | **对比维度**   | **JavaScript (JS)**                              | **TypeScript (TS)**                                          |
  | -------------- | ------------------------------------------------ | ------------------------------------------------------------ |
  | **类型系统**   | 动态类型（运行时确定类型，易因类型错误引发 bug） | 静态类型（编译时类型检查，支持类型注解如 `let age: number = 18`） |
  | **类型工具**   | 无（依赖 JSDoc 注释辅助）                        | 丰富（接口 `interface`、泛型 `Generics`、枚举 `enum`、联合类型等） |
  | **代码维护性** | 小型项目灵活，大型项目易因类型模糊导致协作困难   | 适合大型项目（类型定义清晰，IDE 智能提示强）                 |
  | **兼容性**     | 直接运行在浏览器/Node.js                         | 需编译为 JS（通过 `tsc` 或打包工具转换）                     |

  ---

  ### 3. Vue 3 初始化流程
  | **阶段**         | **关键步骤**                                                 | **说明**                                                   |
  | ---------------- | ------------------------------------------------------------ | ---------------------------------------------------------- |
  | **应用创建**     | `const app = createApp(App)`                                 | 通过 `createApp` 初始化根组件（替代 Vue 2 的 `new Vue()`） |
  | **挂载准备**     | 配置全局属性/插件（如 `app.use(router)`）                    | 类似 Vue 2 的 `Vue.use()`，但作用域限定在当前应用实例      |
  | **挂载到DOM**    | `app.mount('#app')`                                          | 将根组件渲染到指定 DOM 节点（触发后续初始化流程）          |
  | **响应式初始化** | 在 `setup()` 函数中定义响应式数据（`ref`/`reactive`）和计算属性 | 替代 Vue 2 的 `data` 选项，逻辑更集中                      |
  | **虚拟DOM生成**  | 编译模板生成 VNode（虚拟节点），通过 patch 算法对比并更新真实 DOM | 优化点：静态节点标记（减少不必要的比对）                   |

  ---

  ### 4. 路由钩子函数（Vue Router）
  | **钩子类型**     | **具体钩子**        | **触发时机**                                                 | **参数**           | **注意事项**                           |
  | ---------------- | ------------------- | ------------------------------------------------------------ | ------------------ | -------------------------------------- |
  | **全局钩子**     | `beforeEach`        | 路由跳转前（导航被确认前）                                   | `(to, from, next)` | 必须调用 `next()` 才能继续导航         |
  |                  | `afterEach`         | 路由跳转完成后（导航已确认）                                 | `(to, from)`       | 无 `next` 参数，不可中断导航           |
  | **路由独享钩子** | `beforeEnter`       | 在特定路由配置中定义（如 `{ path: '/home', beforeEnter: (to, from, next) => {} }`） | `(to, from, next)` | 仅对该路由生效                         |
  | **组件内钩子**   | `beforeRouteEnter`  | 进入组件前（组件实例未创建，无法访问 `this`）                | `(to, from, next)` | 通过 `next(vm => {})` 回调访问组件实例 |
  |                  | `beforeRouteUpdate` | 当前路由改变但组件复用时（如 `/user/1` → `/user/2`）         | `(to, from, next)` | 可访问 `this`                          |
  |                  | `beforeRouteLeave`  | 离开组件前（常用于表单未保存提示）                           | `(to, from, next)` | 可访问 `this`                          |

  ---

  ### 5. Vuex（状态管理核心概念）
  | **模块**      | **作用**                                                     | **关键方法/属性**                                            | **使用场景**                     |
  | ------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------------- |
  | **State**     | 存储全局共享数据（单一状态树）                               | 通过 `this.$store.state.xxx` 访问（或 `mapState` 辅助函数）  | 用户信息、全局配置、主题设置等   |
  | **Getters**   | 基于 State 的计算属性（派生状态）                            | 通过 `this.$store.getters.xxx` 访问（类似 Vue 的 `computed`） | 格式化用户信息、过滤列表数据等   |
  | **Mutations** | **唯一修改 State 的方式**（同步操作）                        | 通过 `commit('mutationName', payload)` 触发（如 `commit('SET_USER', user)`） | 必须同步更新状态（便于调试追踪） |
  | **Actions**   | 处理异步操作（如 API 请求），最终通过 `commit` 提交 Mutation | 通过 `dispatch('actionName', payload)` 触发（如 `dispatch('fetchUser')`） | 异步登录、数据加载等             |

  ---

  ### 6. nextTick
  | **作用**     | **原理**                                                     | **使用场景**                                                 | **底层实现**                                                 |
  | ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | **核心功能** | 在下次 DOM 更新循环结束后执行回调（确保获取更新后的 DOM 结构） | 在修改响应式数据后，需要操作更新后的 DOM 时（如获取元素宽度、滚动位置） | 基于微任务队列（优先级顺序：Promise > MutationObserver > setImmediate > setTimeout） |

  ---

  ### 7. keep-alive
  | **功能** | **核心机制**                                              | **相关属性**                                                 | **生命周期**                                                 |
  | -------- | --------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | **作用** | 缓存动态组件或路由组件实例，避免重复销毁/创建（提升性能） | `include`：字符串/正则/数组，指定需缓存的组件名（如 `include="Home,About"`） | 被缓存的组件触发：<br>• `activated`（激活时）<br>• `deactivated`（停用时） |
  |          |                                                           | `exclude`：排除不需要缓存的组件名                            |                                                              |
  |          |                                                           | `max`：限制最大缓存实例数（超出时移除最久未使用的缓存）      |                                                              |

  ---

  ### 8. 路由 Hash 模式 vs History 模式
  | **对比维度**   | **Hash 模式**                                    | **History 模式**                                             |
  | -------------- | ------------------------------------------------ | ------------------------------------------------------------ |
  | **URL 表现**   | 带 `#`（如 `http://example.com/#/home`）         | 无 `#`（如 `http://example.com/home`）                       |
  | **监听机制**   | 通过 `window.onhashchange` 监听 `#` 后部分的变化 | 依赖 HTML5 `history.pushState` API（需浏览器支持）           |
  | **服务器配置** | 无需特殊配置（所有请求均返回 index.html）        | **必须配置**：服务器将所有路径请求重定向到 index.html（避免 404） |
  | **兼容性**     | 兼容所有浏览器（包括 IE9）                       | 仅支持现代浏览器（IE10+）                                    |

  ---

  ### 9. JavaScript 原型链
  | **核心概念**   | **说明**                                                     | **示例**                                                     |
  | -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | **原型对象**   | 每个函数都有一个 `prototype` 属性（构造函数的原型），实例通过 `__proto__` 访问其原型 | `function Person() {}; Person.prototype.sayHi = function() {};` |
  | **原型链继承** | 实例的 `__proto__` 指向其构造函数的 `prototype`，最终指向 `Object.prototype`（顶层为 `null`） | `const p = new Person(); p.__proto__ === Person.prototype // true` |
  | **作用**       | 实现属性和方法的共享（如所有对象继承 `Object.prototype.toString`） |                                                              |

  ---

  ### 10. this 指向规则
  | **绑定规则** | **触发场景**                               | **this 指向**                                                | **特殊情况**                                                 |
  | ------------ | ------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | **默认绑定** | 独立函数调用（非方法/构造函数）            | 非严格模式：`window`；严格模式：`undefined`                  | `function fn() { console.log(this); } fn();`                 |
  | **隐式绑定** | 方法调用（对象.方法）                      | 调用该方法的对象                                             | `const obj = { fn() { console.log(this); } }; obj.fn(); // obj` |
  | **显式绑定** | 通过 `call`/`apply`/`bind` 强制指定 this   | 指定的第一个参数（如 `fn.call(obj)` 中 this 为 obj）         | `bind` 返回新函数，需手动调用                                |
  | **new 绑定** | 构造函数调用（`new Constructor()`）        | 新创建的实例                                                 | `function Person() { this.name = 'Tom'; } const p = new Person();` |
  | **箭头函数** | 无自己的 this，继承定义时的上下文中的 this | 外层作用域的 this（如全局箭头函数继承 window，或外层函数的 this） | 无法通过 `call`/`apply`/`bind` 修改                          |

  ---

  ### 11. 浏览器渲染原理（关键步骤）
  | **阶段**              | **详细过程**                                                 | **优化关联点**                                             |
  | --------------------- | ------------------------------------------------------------ | ---------------------------------------------------------- |
  | **HTML 解析**         | 从网络接收 HTML 字节流，逐步构建 DOM 树（遇到外部资源如 CSS/JS 会暂停解析） | 内联关键 CSS、异步加载 JS（`async`/`defer`）可加速首屏渲染 |
  | **CSS 解析**          | 解析 CSS 文件生成 CSSOM 树（描述样式规则与元素的映射关系）   | 避免复杂选择器、减少嵌套层级可提升解析速度                 |
  | **渲染树合成**        | 合并 DOM 树和 CSSOM 树，生成渲染树（排除 `display: none` 等不可见元素） | 减少重排/重绘范围（如通过 CSS Transform 代替位置变动）     |
  | **布局（Layout）**    | 计算每个渲染树节点的大小和位置（如宽高、边距、定位）         | 避免频繁修改几何属性（如 width/height）触发全量重排        |
  | **绘制（Paint）**     | 将布局结果转换为屏幕像素（填充颜色、绘制文本/图像）          | 使用 GPU 加速属性（如 `transform`/`opacity`）减少重绘成本  |
  | **合成（Composite）** | 分层渲染（浏览器将图层合并为最终画面，利用 GPU 并行处理提升性能） | 合理使用 `will-change` 提示浏览器优化特定元素的合成        |

  ---

  ### 12. 事件机制 - 冒泡
  | **事件流阶段** | **触发顺序**                         | **关键方法**                                                 | **应用场景**                       |
  | -------------- | ------------------------------------ | ------------------------------------------------------------ | ---------------------------------- |
  | **捕获阶段**   | 从 `window` 到目标元素（从外到内）   | 通过 `addEventListener(event, handler, true)` 第三个参数设为 `true` | 特殊场景（如全局拦截事件）         |
  | **目标阶段**   | 到达实际触发事件的元素（如按钮点击） | -                                                            | -                                  |
  | **冒泡阶段**   | 从目标元素到 `window`（从内到外）    | 默认行为（可通过 `e.stopPropagation()` 阻止冒泡）            | 事件委托（在父元素监听子元素事件） |

  ---

  13.讲一个你项目的亮点？

  反问：
  1-业务-大数据平台（核心业务）但是实习生能做的不多，就是改bug而已

  2-转正吗？要问领导才知道

  3-什么时候出结果？很快就出的（一个小时后）



# 太平洋网络前端面试复盘（八股文知识点详解）

## 面试概览
- **时长**：24分钟（20分钟八股文 + 4分钟反问）  
- **面试体验**：面试官敷衍，回答后常沉默并以“好/嗯”回应，疑似 KPI 面试  
- **面试形式**：线上
- **反问反馈**：业务为汽车 To B 系统，无二面，前端贴近业务问题回答敷衍  

---

## 八股文知识点整理

### 1. 水平垂直居中
#### **常见实现方案**
| **方法**                 | **实现代码示例**                                             | **适用场景**                    |
| ------------------------ | ------------------------------------------------------------ | ------------------------------- |
| **Flex 布局**            | 父容器：`display: flex; justify-content: center; align-items: center;`<br>子元素：无需额外样式 | 现代浏览器兼容性好，代码简洁    |
| **绝对定位 + Transform** | 父容器：`position: relative;`<br>子元素：`position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);` | 兼容性广（包括旧浏览器）        |
| **Grid 布局**            | 父容器：`display: grid; place-items: center;`                | 现代浏览器（兼容性略低于 Flex） |
| **表格布局（Table）**    | 父容器：`display: table-cell; vertical-align: middle; text-align: center;`<br>子元素：`display: inline-block;` | 兼容性极好，但语义化较差        |

---

### 2. Flex 布局
#### **核心概念与属性**
| **分类**     | **属性**          | **作用**                                                     | **常用值**                                      |
| ------------ | ----------------- | ------------------------------------------------------------ | ----------------------------------------------- |
| **容器属性** | `display: flex`   | 将元素设为弹性容器                                           | -                                               |
|              | `flex-direction`  | 主轴方向（决定子元素排列方向）                               | `row`（默认横向）、`column`（纵向）             |
|              | `justify-content` | 主轴对齐方式（水平方向）                                     | `center`（居中）、`space-between`（两端对齐）等 |
|              | `align-items`     | 交叉轴对齐方式（垂直方向）                                   | `center`（居中）、`stretch`（拉伸填满）等       |
|              | `flex-wrap`       | 是否换行                                                     | `nowrap`（默认不换行）、`wrap`（换行）          |
| **子项属性** | `flex`            | 子元素占主轴空间比例（`flex-grow` + `flex-shrink` + `flex-basis` 简写） | `1`（均分剩余空间）、`2 1 100px`（自定义）      |
|              | `align-self`      | 单独设置某个子项的交叉轴对齐方式                             | `center`、`flex-start` 等                       |

---

### 3. 盒子模型
#### **标准模型 vs IE 模型**
| **模型类型** | **组成**                                                     | **width/height 计算范围**           | **获取方式**                      |
| ------------ | ------------------------------------------------------------ | ----------------------------------- | --------------------------------- |
| **标准模型** | 内容（content）+ 内边距（padding）+ 边框（border）+ 外边距（margin） | width/height 仅包含内容区域         | `box-sizing: content-box`（默认） |
| **IE 模型**  | 内容（含 padding 和 border）+ 外边距（margin）               | width/height 包含 padding 和 border | `box-sizing: border-box`          |

#### **关键区别**  
- **标准模型**：`width` 仅指内容宽度，总宽度 = `width + padding + border + margin`  
- **IE 模型**：`width` 包含内容和内边距/边框，总宽度 = `width + margin`  

---

### 4. CSS 选择器
#### **优先级排序（从高到低）**
1. **内联样式**（如 `style="color: red;"`）→ 权重 `1000`  
2. **ID 选择器**（如 `#header`）→ 权重 `100`  
3. **类/伪类/属性选择器**（如 `.btn`、`:hover`、`[type="text"]`）→ 权重 `10`  
4. **元素/伪元素选择器**（如 `div`、`::before`）→ 权重 `1`  
5. **通配符/继承样式**（如 `*`、继承的样式）→ 权重 `0`  

#### **常见选择器类型**
- **基础选择器**：标签（`div`）、类（`.class`）、ID（`#id`）、通配符（`*`）  
- **组合选择器**：后代（`div p`）、子代（`div > p`）、相邻兄弟（`div + p`）、通用兄弟（`div ~ p`）  
- **伪类/伪元素**：`:hover`（悬停）、`::before`（前置内容）  

---

### 5. JavaScript 数据类型
#### **基本类型（原始类型）**
- **数值（Number）**：整数/浮点数（如 `42`、`3.14`）  
- **字符串（String）**：文本（如 `"hello"`）  
- **布尔值（Boolean）**：`true`/`false`  
- **Undefined**：未赋值的变量默认值  
- **Null**：表示空对象指针（通常手动赋值）  
- **BigInt**：大整数（如 `12345678901234567890n`，ES2020 新增）  
- **Symbol**：唯一标识符（如 `Symbol('key')`，ES6 新增）  

#### **引用类型（对象类型）**
- **对象（Object）**：键值对集合（如 `{ name: "Tom" }`）  
- **数组（Array）**：特殊对象（如 `[1, 2, 3]`）  
- **函数（Function）**：可调用的对象（如 `function fn() {}`）  

---

### 6. 前端工程化
#### **核心目标**：提升开发效率、代码质量与部署可靠性  
#### **常见工具与流程**
| **环节**     | **工具/技术**                          | **作用**                                                |
| ------------ | -------------------------------------- | ------------------------------------------------------- |
| **代码规范** | ESLint（语法检查）、Prettier（格式化） | 统一团队代码风格，减少低级错误                          |
| **模块化**   | ES Modules（原生）、CommonJS           | 拆分代码为独立模块（如 `import/require`）               |
| **构建工具** | Webpack、Vite、Rollup                  | 打包资源（JS/CSS/图片）、代码压缩、Tree-shaking、热更新 |
| **自动化**   | npm scripts、Gulp、Grunt               | 执行标准化任务（如编译、测试、部署）                    |
| **版本控制** | Git + GitFlow                          | 管理代码版本，协作开发                                  |
| **测试**     | Jest（单元测试）、Cypress（E2E）       | 保障代码功能正确性                                      |

---

### 7. 自动化测试（补充常见工具）
#### **测试类型与工具**
| **测试类型** | **常用工具**          | **用途**                                      |
| ------------ | --------------------- | --------------------------------------------- |
| **单元测试** | Jest、Vitest          | 测试最小功能单元（如函数/组件）               |
| **组件测试** | Vue Test Utils + Jest | 针对 Vue 组件的交互与渲染测试                 |
| **E2E 测试** | Cypress、Playwright   | 模拟用户操作，测试完整业务流程（如登录→下单） |
| **静态检查** | ESLint、Stylelint     | 检查代码语法与样式规范                        |

---

### 8. Vue 指令
#### **常用内置指令**
| **指令**     | **作用**                                        | **示例**                                                     |
| ------------ | ----------------------------------------------- | ------------------------------------------------------------ |
| `v-if`       | 条件渲染（元素是否存在）                        | `<div v-if="isVisible">内容</div>`                           |
| `v-show`     | 条件显示（通过 CSS `display` 控制）             | `<div v-show="isVisible">内容</div>`                         |
| `v-for`      | 列表渲染（遍历数组/对象）                       | `<li v-for="item in list" :key="item.id">{{ item.name }}</li>` |
| `v-bind` (:) | 动态绑定属性（如 `class`/`src`）                | ``                                                           |
| `v-on` (@)   | 绑定事件（如点击、输入）                        | `<button @click="handleClick">提交</button>`                 |
| `v-model`    | 双向数据绑定（表单输入元素）                    | `<input v-model="message" />`                                |
| `v-slot`     | 插槽作用域（Vue 2.6+ 用 `v-slot:` 或 `#` 简写） | `<template #header>标题</template>`                          |

---

### 9. Vue 3 比 Vue 2 的提升
| **改进点**          | **Vue 2**                                              | **Vue 3**                                                    |
| ------------------- | ------------------------------------------------------ | ------------------------------------------------------------ |
| **响应式原理**      | `Object.defineProperty`（无法监听新增/删除属性）       | `Proxy`（支持动态响应，性能更优）                            |
| **Composition API** | 不支持（依赖 Options API：data/methods/computed 分散） | 新增 `setup` 函数 + Composition API（逻辑复用更灵活，解决代码拆分问题） |
| **TypeScript 支持** | 较弱（类型推断困难）                                   | 原生友好（类型定义完善，适合大型项目）                       |
| **性能优化**        | 全量虚拟 DOM 对比                                      | 静态节点提升、Patch Flag 精准更新、Tree-shaking 支持（按需引入 API） |
| **其他**            | 不支持 Fragment（单根节点）、Teleport（传送门）        | 支持多根节点、Teleport（跨 DOM 层级渲染）、Suspense（异步组件优化） |

---

### 10. 为什么 Vite 比 Webpack 快？
| **对比维度**      | **Vite**                                        | **Webpack**                                         |
| ----------------- | ----------------------------------------------- | --------------------------------------------------- |
| **启动阶段**      | 基于浏览器原生 ESM（直接加载源码，无需打包）    | 需先打包（依赖 Webpack 的复杂解析和编译流程）       |
| **依赖预构建**    | 首次启动时预构建依赖（后续直接用缓存）          | 每次启动均需重新解析依赖                            |
| **热更新（HMR）** | 基于 ESM 原生热替换（仅更新变动模块，速度极快） | 依赖 Webpack 的重新编译和打包（全量或部分重新构建） |
| **构建工具**      | 生产环境用 Rollup（优化过的打包速度）           | 自身打包逻辑较重（解析/编译/优化步骤多）            |
| **适用场景**      | 开发环境极致速度（适合现代浏览器项目）          | 适合复杂项目（功能全面但启动慢）                    |

---

### 11. 常用 AI 工具及使用方式（示例）
#### **前端开发相关 AI 工具**
| **工具类型** | **代表工具**      | **使用场景**                                | **操作示例**                              |
| ------------ | ----------------- | ------------------------------------------- | ----------------------------------------- |
| **代码生成** | GitHub Copilot    | 根据注释/上下文生成代码片段（如函数、组件） | 输入 `// 实现一个 Vue 组件`，自动生成模板 |
| **代码优化** | ChatGPT / Claude  | 优化现有代码（如性能、可读性）              | 提问“如何优化这段 Vue 渲染逻辑？”         |
| **文档查询** | Stack Overflow AI | 快速获取技术问题解决方案                    | 输入“Vue 3 如何实现响应式数据？”          |
| **设计辅助** | Figma AI 插件     | 生成 UI 设计稿或布局代码                    | 描述“一个登录页面”，生成 Figma 原型       |

#### **典型使用流程**  
1. **需求描述**：明确问题（如“实现一个带防抖的搜索输入框”）。  
2. **工具交互**：通过对话输入需求（或粘贴代码片段）。  
3. **结果验证**：检查生成的代码逻辑，补充边界条件处理。  

---

### 12. 前端如何更贴近业务？（反问延伸思考）
#### **常见贴合方式**  
- **需求深度参与**：与产品经理/设计师早期沟通，理解业务目标（如汽车 To B 系统的用户角色权限设计）。  
- **技术选型适配**：根据业务场景选择方案（如高并发数据看板用虚拟滚动优化渲染）。  
- **数据驱动反馈**：通过埋点分析用户行为，针对性优化交互流程（如表单提交失败率高的环节）。  
- **跨团队协作**：主动了解业务方痛点（如销售团队需要实时订单状态更新），推动功能迭代。  

---

## 反问环节记录
1. **业务方向**：汽车 To B 系统（推测为后台管理系统，侧重数据展示与流程审批）。  
2. **面试流程**：单轮面试无二面（可能为急招或 KPI 指标导向）。  
3. **前端贴近业务**：面试官回答敷衍（需自行通过项目实践或主动沟通探索）。  

---

## 总结建议
- **八股文重点**：掌握基础知识点（如 Flex 布局、盒模型、Vue 响应式原理），结合实际项目举例。  
- **面试应对**：若遇敷衍面试官，保持清晰逻辑表达，反问环节主动挖掘业务与技术结合点。  
- **业务理解**：前端需跳出“写代码”思维，关注业务目标（如汽车 To B 系统的用户效率提升）。

# 钛动科技前端面试复盘（项目深度拷打版）

## 面试概览
- **时长**：23分钟（20分钟项目拷打 + 5分钟反问）  
- **面试形式**：线上（推测）  
- **面试体验**：无八股文提问，聚焦实习项目细节深挖，面试官对部分技术点（如 agent 时代前端转型）认知有限  
- **反问反馈**：业务为广告业务，实习结果预计次日中午前公布  

---

## 面试问题与知识点拆解

### 一、自我介绍 & 离职动机
- **问题**：请简要自我介绍，并说明从上一家公司离职的原因。  
- **考察点**：  
  - 自我表达能力（清晰描述工作经历、技术栈）  
  - 职业稳定性（离职原因合理性，如发展瓶颈、技术方向不符等）  

---

### 二、项目深度拷打（核心考察点）

#### 1. 模块联邦架构（重点！）
- **问题**：  
  - 请阐述模块联邦（Module Federation）的架构原理？  
  - 你的项目为什么选择使用模块联邦？  
- **知识点解析**：  
  | **核心概念** | **说明**                                                     | **项目应用场景**                      |
  | ------------ | ------------------------------------------------------------ | ------------------------------------- |
  | **定义**     | 微前端架构方案之一，允许不同应用（独立构建）动态共享代码模块（如组件/工具函数） | 多团队协作的大型项目（避免重复开发）  |
  | **核心能力** | 跨应用共享依赖（如 React/Vue）、按需加载远程模块、独立部署与更新 | 你的项目可能涉及多团队模块复用        |
  | **技术实现** | 基于 Webpack 5 的 `ModuleFederationPlugin` 插件（配置暴露模块与远程引用） | 需熟悉 Webpack 配置与模块加载逻辑     |
  | **优势**     | 减少代码冗余、提升开发效率、支持动态更新（无需整体重新部署） | 解决多项目共用组件/工具的维护成本     |
  | **可能追问** | 如何解决模块版本冲突？如何保证远程模块加载的稳定性？         | 需提及版本管理（如 SemVer）与容错机制 |

- **回答建议**：  
  结合项目背景说明使用动机（如“项目中 A/B 团队分别开发用户中心与订单模块，通过模块联邦共享基础组件库，避免重复打包”），并简述配置关键点（暴露模块、远程引用方式）。

#### 2. 首屏优化策略
- **问题**：你在项目中做了哪些首屏性能优化？  
- **常见优化方向**（需结合项目实际选择 2-3 点展开）：  
  | **优化手段**      | **具体措施**                                                 | **效果**             |
  | ----------------- | ------------------------------------------------------------ | -------------------- |
  | **资源压缩**      | 压缩 HTML/CSS/JS（如使用 Terser、CSSNano）、图片转 WebP/AVIF 格式 | 减少首屏加载体积     |
  | **代码分割**      | 通过 Webpack 的 `SplitChunksPlugin` 拆分公共代码与异步路由组件 | 避免首屏加载无关代码 |
  | **CDN 加速**      | 静态资源（JS/CSS/图片）部署到 CDN，利用边缘节点就近访问      | 降低网络延迟         |
  | **预加载/预渲染** | 使用 `<link rel="preload">` 预加载关键资源，或 SSR/SSG 预渲染首屏 HTML | 提升首屏渲染速度     |
  | **懒加载**        | 非首屏组件/路由采用动态导入（如 `import('./Component')`）    | 延迟加载非必要资源   |

- **回答示例**：  
  “首屏优化主要做了三件事：一是通过 Webpack 的 SplitChunksPlugin 将公共库（如 React/Vue）抽离为单独 chunk，减少重复加载；二是关键 CSS 内联到 HTML，避免阻塞渲染；三是图片资源转 WebP 格式并启用 CDN 加速，整体首屏加载时间缩短了约 40%。”

#### 3. 大文件上传优化
- **问题**：实习期间如何优化大文件上传流程？  
- **常见优化方案**（技术细节需展开）：  
  | **优化点**     | **具体实现**                                                 | **解决的问题**               |
  | -------------- | ------------------------------------------------------------ | ---------------------------- |
  | **分片上传**   | 将大文件切割为多个小块（如 1MB/片），通过并发请求分批上传    | 避免单次请求超时/失败风险    |
  | **断点续传**   | 记录已上传分片的进度（如本地存储/服务端标记），中断后从断点继续上传 | 提升上传成功率，节省流量     |
  | **进度反馈**   | 通过 XMLHttpRequest 的 `onprogress` 事件或 Fetch API 的流式处理实时显示进度 | 优化用户体验（感知上传状态） |
  | **压缩预处理** | 前端对图片/视频等文件进行适当压缩（如 Canvas 压缩图片）再上传 | 减少传输数据量               |
  | **并发控制**   | 限制同时上传的分片数量（如 3-5 个并发），避免浏览器或服务器压力过大 | 平衡上传速度与稳定性         |

- **回答示例**：  
  “针对大文件上传，我实现了分片上传 + 断点续传功能：首先将文件按 1MB 切片，通过 FormData 分批发送到服务端；服务端记录已接收的分片 ID，若上传中断，前端从上次成功的切片继续；同时用进度条实时显示上传百分比，最终上传成功率从 70% 提升到了 95%。”

#### 4. 技术问题解决思路
- **问题**：遇到技术难题时，你的解决流程是什么？  
- **考察点**：  
  - 问题排查能力（如日志分析、断点调试）  
  - 学习能力（查阅文档/社区方案）  
  - 协作能力（是否请教同事/导师）  
- **回答框架**：  
  “首先我会通过浏览器开发者工具（如 Network 面板、Console 日志）定位问题现象（如接口报错、渲染异常）；然后根据错误信息查阅官方文档或搜索类似案例（如 Stack Overflow）；若仍无法解决，会向团队有经验的同事请教；最后总结问题根因与解决方案，避免重复踩坑。”  

---

### 三、反问环节
- **提问内容**：  
  1. 业务方向：广告业务的具体技术需求（如广告投放系统的实时数据处理？）  
  2. 前端转型：在 AI Agent 时代（如智能客服、自动化营销工具），前端工程师需要具备哪些新技能？（面试官表示不太了解）  
  3. 实习福利与结果：实习薪资/补贴情况，最快何时能收到面试结果（预计次日中午前）。  
- **面试表现反馈**：  
  - 优点：两年半经验匹配岗位需求，项目经验丰富。  
  - 缺点：模块联邦部分讲解不够详细（需补充技术细节）。  

---

## 总结建议
- **重点复盘**：模块联邦架构原理（Webpack 配置）、首屏优化具体手段（代码分割/CDN/预加载）、大文件上传分片与断点续传实现逻辑。  
- **项目表达**：回答时结合业务场景（如“为了解决多团队协作重复开发问题”），突出技术选型的合理性。  
- **缺陷改进**：针对模块联邦的薄弱点，补充版本冲突解决、远程模块容错等细节（可参考 Webpack 官方文档）。  
- **反问策略**：优先问业务技术细节（体现对岗位的理解），其次关注职业发展（如转型方向）。



## 360前端实习面

### 面试概览
- **时长**：40 分钟左右
- **面试形式**：线上（推测）
- **面试体验**：聚焦四段实习经历（重点拷打项目组件封装）、前端基础细节（HTML/CSS/JS/框架原理）
- **反问反馈**：业务为简单的大模型基建平台（与传统前端开发类似），面试结果最快 3 天内公布

### 面试问题与知识点拆解
1. **自我介绍与项目深挖**
    - **问题**：介绍四段实习经历，重点描述每段实习的具体工作内容，并对项目（尤其是组件封装部分）进行深入讨论
    - **考察点**：项目经验真实性与完整性（能否清晰描述职责、技术栈、成果）、组件封装能力（如何设计可复用组件、优化性能）、自我反思与优化意识（是否能主动提出或接受优化建议）
    - **组件封装补充优化点（面试官可能提及）**：设计原则（遵循单一职责原则、开闭原则）、性能优化（避免不必要的重新渲染，如使用 `React.memo` 或 `Vue v-memo`，合理拆分组件以减少渲染范围）、可维护性（清晰的 props 定义与事件通信机制，添加必要的注释与文档）、复用性（提取通用逻辑到高阶组件（HOC）或自定义 Hook（Vue Composition API）中）
2. **前端基础知识点**
    - **HTML：id 与 class 的区别**
        - **id**：唯一标识页面中的一个元素（全局唯一），用于锚点跳转、JavaScript 精准操作特定元素，一个页面中 id 不能重复
        - **class**：为元素定义样式类（可重复使用），批量设置元素的样式（如多个按钮统一样式），一个元素可以有多个 class，多个元素可以共享同一个 class
    - **为什么不用原生 JS，而选择框架（如 Vue/React）**
        - **原生 JS 的局限性**：DOM 操作繁琐，频繁操作 DOM 会导致性能问题；代码复用性差，难以维护大型项目；状态管理复杂，数据与视图同步需要手动处理
        - **框架的优势**：组件化开发，提高开发效率与代码可维护性；虚拟 DOM，通过虚拟 DOM 的差异比较减少真实 DOM 操作，提升渲染性能；状态管理，提供响应式数据机制，自动同步数据与视图；生态丰富，拥有大量的第三方库和工具，加速开发流程
    - **`==` 与 `===` 的区别**
        - **`==`**：宽松相等，比较时会进行类型转换（如数字 `1` 和字符串 `"1"` 相等），一个页面中应避免使用，易引发隐式类型转换错误
        - **`===`**：严格相等，比较值和类型都必须相同（不进行类型转换），推荐使用，代码更安全可靠
    - **开发中用的框架布局（Flex）**
        - **核心概念**：Flex 布局（弹性布局）通过 `display: flex` 将容器设为弹性容器，子元素成为弹性项目，可灵活控制其在主轴（默认横向）和交叉轴（默认纵向）上的排列与对齐方式
        - **常用属性**：容器属性（`flex-direction` 主轴方向、`justify-content` 主轴对齐方式、`align-items` 交叉轴对齐方式）、子项属性（`flex` 子元素占主轴空间的比例、`align-self` 单独设置某个子项的交叉轴对齐方式）
    - **怎么实现弹窗的水平垂直居中**
        - **Flex 布局方案（推荐）**：父容器 `display: flex; justify-content: center; align-items: center;`，子元素为弹窗内容，父容器设置 `position: fixed` 覆盖全屏
        - **绝对定位 + Transform 方案**：子元素（弹窗内容）`position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);`
    - **怎么判断数组**
        - **`Array.isArray()`（推荐）**：`const arr = [1, 2, 3]; console.log(Array.isArray(arr)); // true`
        - **`instanceof Array`（注意跨 iframe 问题）**：`console.log(arr instanceof Array); // true`
    - **`instanceof` 基于什么去判断的**
        - **原理**：检查对象的原型链上是否存在构造函数的 `prototype` 属性
        - **示例**：`function Person() {}; const p = new Person(); console.log(p instanceof Person); // true`，局限性是对于跨 iframe 或不同全局环境下的对象，可能判断不准确
    - **let、const、VAR 区别**
        - **作用域**：`var` 是函数作用域/全局作用域，`let` 和 `const` 是块级作用域
        - **是否可重复声明**：`var` 可重复声明，`let` 和 `const` 不可重复声明
        - **是否可重新赋值**：`var` 和 `let` 可重新赋值，`const` 不可重新赋值（但对于对象和数组，其内容可修改）
        - **变量提升**：`var` 存在变量提升（初始化为 undefined），`let` 和 `const` 存在暂时性死区，不可变量提升
    - **如果一个不定参数的方法，如果获取里面参数**
        - **使用 `arguments` 对象（ES5 及以前）**：通过 `arguments` 对象遍历参数
        - **使用剩余参数（Rest Parameters，ES6 推荐）**：`function sum(...args) { return args.reduce((acc, val) => acc + val, 0); }`
    - **v-show 和 v-if**
        - **原理**：`v-show` 通过 CSS 的 `display` 属性控制元素显示/隐藏（元素始终存在于 DOM 中），`v-if` 条件为真时渲染元素到 DOM 中，条件为假时从 DOM 中移除（元素不存在于 DOM 中）
        - **适用场景**：`v-show` 适用于频繁切换显示状态（如选项卡切换），`v-if` 适用于条件很少改变（如权限控制显示模块）
        - **性能影响**：`v-show` 初始渲染开销小，切换开销极小；`v-if` 初始渲染开销大（需创建/销毁元素）
    - **父子传值**
        - **父传子**：通过 `props` 将数据从父组件传递给子组件（Vue 中通过 `:propName="value"`，React 中通过 `props.propName`）
        - **子传父**：通过自定义事件（Vue 中使用 `$emit` 触发事件，父组件监听；React 中通过回调函数作为 `props` 传递给子组件）
    - **eventbus 讲一下**
        - **原理**：创建一个全局的事件中心（通常是一个 Vue 实例或对象），组件通过 `$on`（Vue）或 `on`（自定义实现）监听事件，通过 `$emit`（Vue）或 `emit`（自定义实现）触发事件，实现非父子组件间的通信
        - **示例（Vue 2）**：创建 `eventBus.js` 导出 Vue 实例，组件 A 通过 `eventBus.$emit('eventName', data)` 触发事件，组件 B 通过 `eventBus.$on('eventName', (data) => { console.log(data); })` 监听事件
        - **缺点**：在大型项目中可能导致事件管理混乱，推荐使用 Vuex（Vue）或 Redux（React）等状态管理库替代
    - **点击按钮获取数据怎么实现**
        - **步骤**：给按钮绑定点击事件（如 Vue 的 `@click` 或 React 的 `onClick`）；在事件处理函数中发起数据请求（如使用 `fetch`、`axios`）；将获取到的数据更新到组件的状态中（如 Vue 的 `data` 或 React 的 `state`）
        - **示例（Vue + fetch）**：模板中按钮绑定 `@click="fetchData"`，方法中通过 `fetch` 请求数据，将响应数据更新到 `data` 中
    - **fetch 用 await 之后，方法设置一些 function**
        - **正确用法**：`fetch` 返回一个 Promise，使用 `await` 等待其完成，然后可以在 `async` 函数中继续执行后续操作（如处理响应数据、调用其他函数）
        - **示例**：`async function getData() { try { const response = await fetch('https://api.example.com/data'); const data = await response.json(); console.log(data); processData(data); } catch (error) { console.error('获取数据失败:', error); } } function processData(data) { /* 处理数据的逻辑 */ }`
3. **反问环节**
    - **问题**：业务、面试结果时间
    - **回答**：业务是简单的大模型基建平台，传统前端一样，最快三天内出结果
