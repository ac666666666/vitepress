# åˆå¹¶ K ä¸ªå‡åºé“¾è¡¨

## 1. é¢˜ç›®å‘ˆç°

**éš¾åº¦ç­‰çº§**ï¼šğŸ”´ å›°éš¾  
**æ ¸å¿ƒè€ƒå¯Ÿç‚¹**ï¼šé“¾è¡¨ã€åˆ†æ²»ã€æœ€å°å † (ä¼˜å…ˆé˜Ÿåˆ—)

ç»™ä½ ä¸€ä¸ªé“¾è¡¨æ•°ç»„ï¼Œæ¯ä¸ªé“¾è¡¨éƒ½å·²ç»æŒ‰å‡åºæ’åˆ—ã€‚

è¯·ä½ å°†æ‰€æœ‰é“¾è¡¨åˆå¹¶åˆ°ä¸€ä¸ªå‡åºé“¾è¡¨ä¸­ï¼Œè¿”å›åˆå¹¶åçš„é“¾è¡¨ã€‚

> **ç¤ºä¾‹ 1ï¼š**
>
> **è¾“å…¥**ï¼šlists = [[1,4,5],[1,3,4],[2,6]]  
> **è¾“å‡º**ï¼š[1,1,2,3,4,4,5,6]  
> **è§£é‡Š**ï¼šé“¾è¡¨æ•°ç»„å¦‚ä¸‹ï¼š  
> [  
>   1->4->5,  
>   1->3->4,  
>   2->6  
> ]  
> å°†å®ƒä»¬åˆå¹¶åˆ°ä¸€ä¸ªæœ‰åºé“¾è¡¨ä¸­å¾—åˆ°ã€‚  
> 1->1->2->3->4->4->5->6

> **ç¤ºä¾‹ 2ï¼š**
>
> **è¾“å…¥**ï¼šlists = []  
> **è¾“å‡º**ï¼š[]

> **ç¤ºä¾‹ 3ï¼š**
>
> **è¾“å…¥**ï¼šlists = [[]]  
> **è¾“å‡º**ï¼š[]

---

## 2. è§£é¢˜æ€è·¯æ‹†è§£

### æ–¹æ³•ä¸€ï¼šåˆ†æ²»æ³• (Merge Sort æ€æƒ³)

è¿™é“é¢˜å…¶å®æ˜¯ "åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨" çš„æ¨å¹¿ã€‚
æˆ‘ä»¬å¯ä»¥ä¸¤ä¸¤åˆå¹¶ï¼š
1.  å°† `lists` ä¸­çš„é“¾è¡¨ä¸¤ä¸¤é…å¯¹åˆå¹¶ã€‚
2.  åˆå¹¶åï¼Œ`lists` é•¿åº¦å‡åŠã€‚
3.  é‡å¤ä¸Šè¿°è¿‡ç¨‹ï¼Œç›´åˆ°åªå‰©ä¸‹ä¸€ä¸ªé“¾è¡¨ã€‚

ä¾‹å¦‚æœ‰ 4 ä¸ªé“¾è¡¨ï¼š`L1, L2, L3, L4`
*   ç¬¬ä¸€è½®ï¼šåˆå¹¶ `(L1, L2)` å¾—åˆ° `M1`ï¼Œåˆå¹¶ `(L3, L4)` å¾—åˆ° `M2`ã€‚
*   ç¬¬äºŒè½®ï¼šåˆå¹¶ `(M1, M2)` å¾—åˆ°æœ€ç»ˆç»“æœã€‚

### æ–¹æ³•äºŒï¼šæœ€å°å † (ä¼˜å…ˆé˜Ÿåˆ—)

ç»´æŠ¤ä¸€ä¸ªå¤§å°ä¸º `k` (é“¾è¡¨æ¡æ•°) çš„æœ€å°å †ã€‚
1.  å°†æ¯ä¸ªé“¾è¡¨çš„å¤´èŠ‚ç‚¹åŠ å…¥å †ã€‚
2.  æ¯æ¬¡ä»å †ä¸­å–å‡ºæœ€å°çš„èŠ‚ç‚¹ï¼ˆå †é¡¶ï¼‰ï¼Œæ¥åˆ°ç»“æœé“¾è¡¨åé¢ã€‚
3.  å¦‚æœè¿™ä¸ªèŠ‚ç‚¹æœ‰ `next`ï¼Œå°†å…¶ `next` æ”¾å…¥å †ä¸­ã€‚
4.  é‡å¤ç›´åˆ°å †ä¸ºç©ºã€‚

JavaScript æ²¡æœ‰å†…ç½®çš„ PriorityQueueï¼Œæ‰‹å†™å †æ¯”è¾ƒéº»çƒ¦ï¼Œé¢è¯•ä¸­é€šå¸¸å…è®¸ä½¿ç”¨ **åˆ†æ²»æ³•**ï¼Œå› ä¸ºå®ƒçš„å¤æ‚åº¦ä¹Ÿæ˜¯ä¼˜ç§€çš„ $O(N \log k)$ã€‚

---

## 3. ä»£ç å®ç° (åˆ†æ²»æ³•)

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */

/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function(lists) {
    if (lists.length === 0) return null;
    return merge(lists, 0, lists.length - 1);
};

// åˆ†æ²»åˆå¹¶
function merge(lists, left, right) {
    if (left === right) return lists[left];
    
    const mid = Math.floor((left + right) / 2);
    const l1 = merge(lists, left, mid);
    const l2 = merge(lists, mid + 1, right);
    
    return mergeTwoLists(l1, l2);
}

// åŸºç¡€å‡½æ•°ï¼šåˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨
function mergeTwoLists(l1, l2) {
    const dummy = new ListNode(0);
    let curr = dummy;
    
    while (l1 && l2) {
        if (l1.val <= l2.val) {
            curr.next = l1;
            l1 = l1.next;
        } else {
            curr.next = l2;
            l2 = l2.next;
        }
        curr = curr.next;
    }
    
    curr.next = l1 ? l1 : l2;
    return dummy.next;
}
```

#### ä»£ç æ‰§è¡Œæ¼”ç¤º
è¾“å…¥ `lists = [L1, L2, L3]` (å‡è®¾ L1=[1], L2=[2], L3=[3])

1.  `merge(0, 2)`:
    *   mid = 1.
    *   Call `merge(0, 1)` -> returns merged(L1, L2).
    *   Call `merge(2, 2)` -> returns L3.
    *   Merge `merged(L1, L2)` and `L3`.
2.  Inside `merge(0, 1)`:
    *   mid = 0.
    *   Call `merge(0, 0)` -> returns L1.
    *   Call `merge(1, 1)` -> returns L2.
    *   Merge `L1` and `L2`.

---

## 4. å¤æ‚åº¦åˆ†æ

| ç»´åº¦ | æè¿° |
| :--- | :--- |
| **æ—¶é—´å¤æ‚åº¦** | $O(N \log k)$ã€‚$N$ æ˜¯æ‰€æœ‰èŠ‚ç‚¹æ€»æ•°ï¼Œ$k$ æ˜¯é“¾è¡¨æ¡æ•°ã€‚åˆ†æ²»æ ‘çš„é«˜åº¦æ˜¯ $\log k$ï¼Œæ¯ä¸€å±‚éƒ½éœ€è¦éå† $N$ ä¸ªèŠ‚ç‚¹ã€‚ |
| **ç©ºé—´å¤æ‚åº¦** | $O(\log k)$ã€‚é€’å½’æ ˆçš„æ·±åº¦ã€‚ |
