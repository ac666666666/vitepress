# 两数相加

## 1. 题目呈现

**难度等级**：🟡 中等  
**核心考察点**：链表、数学、模拟

给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

> **示例 1：**
>
> **输入**：l1 = [2,4,3], l2 = [5,6,4]  
> **输出**：[7,0,8]  
> **解释**：342 + 465 = 807.

> **示例 2：**
>
> **输入**：l1 = [0], l2 = [0]  
> **输出**：[0]

> **示例 3：**
>
> **输入**：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]  
> **输出**：[8,9,9,9,0,0,0,1]

---

## 2. 解题思路拆解

### 方法：模拟加法 (进位处理)

这道题其实就是模拟我们在纸上做竖式加法的过程。因为链表是逆序存储的（个位在头节点），这正好符合我们从个位开始相加的习惯。

1.  **指针遍历**：同时遍历两个链表 `l1` 和 `l2`。
2.  **求和**：对于每一位，计算 `sum = val1 + val2 + carry`。
    *   `val1` 是 `l1` 当前节点的值（如果 `l1` 走完了就是 0）。
    *   `val2` 是 `l2` 当前节点的值（如果 `l2` 走完了就是 0）。
    *   `carry` 是上一位的进位。
3.  **更新进位**：`newCarry = Math.floor(sum / 10)`。
4.  **构建节点**：新节点的值为 `sum % 10`。
5.  **循环结束**：当 `l1` 和 `l2` 都走完，**且** `carry` 为 0 时，循环结束。如果最后还有进位（例如 5+5=10），需要补一个值为 1 的节点。

---

## 3. 代码实现

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */

/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
    const dummy = new ListNode(0); // 哨兵节点
    let curr = dummy;
    let carry = 0;
    
    // 只要 l1 没走完，或者 l2 没走完，或者还有进位，就继续
    while (l1 !== null || l2 !== null || carry > 0) {
        const x = l1 ? l1.val : 0;
        const y = l2 ? l2.val : 0;
        
        const sum = x + y + carry;
        
        carry = Math.floor(sum / 10);      // 计算进位
        curr.next = new ListNode(sum % 10); // 创建新节点
        
        curr = curr.next;
        if (l1) l1 = l1.next;
        if (l2) l2 = l2.next;
    }
    
    return dummy.next;
};
```

#### 代码执行演示
输入 `l1=[2,4,3], l2=[5,6,4]`

*   初始：`carry=0`, `curr` 指向 `dummy`。
*   **第 1 轮**：
    *   `x=2, y=5`
    *   `sum = 2+5+0 = 7`
    *   `carry = 0`
    *   新节点 `7`。`curr` -> `7`。
*   **第 2 轮**：
    *   `x=4, y=6`
    *   `sum = 4+6+0 = 10`
    *   `carry = 1`
    *   新节点 `0`。`curr` -> `0`。
*   **第 3 轮**：
    *   `x=3, y=4`
    *   `sum = 3+4+1 = 8`
    *   `carry = 0`
    *   新节点 `8`。`curr` -> `8`。
*   **结束**：`l1` 空，`l2` 空，`carry` 为 0。
*   返回 `7->0->8`。

---

## 4. 复杂度分析

| 维度 | 描述 |
| :--- | :--- |
| **时间复杂度** | $O(max(m, n))$。遍历的长度取决于较长的那个链表。 |
| **空间复杂度** | $O(1)$。返回值不计入空间复杂度的话，只用了常数空间。（如果计入，则是 $O(max(m, n))$）。 |
